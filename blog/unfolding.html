<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tensor Unfolding</title>
    <meta name="description" content="A look at tensor unfolding and its different definitions. We go through their mathematical properties, and python implementation with NumPy.">

    
<meta name="author" content="Jean Kossaifi">

<meta property="og:title" content="Tensor Unfolding">
<meta property="og:description" content="A look at tensor unfolding and its different definitions. We go through their mathematical properties, and python implementation with NumPy.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://jeankossaifi.com/blog/unfolding.html">
<meta property="og:image" content="https://jeankossaifi.com/static/profile.jpg">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Tensor Unfolding">
<meta name="twitter:description" content="A look at tensor unfolding and its different definitions. We go through their mathematical properties, and python implementation with NumPy.">
<meta name="twitter:image" content="https://jeankossaifi.com/static/profile.jpg">

<link rel="canonical" href="https://jeankossaifi.com/blog/unfolding.html">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Tensor Unfolding",
  "author": {
    "@type": "Person",
    "name": "Jean Kossaifi"
  },
  "datePublished": "2017-03-19",
  "description": "<p>A look at tensor unfolding and its different definitions. We go through their mathematical properties, and python implementation with NumPy.</p>",
  "url": "https://jeankossaifi.com/blog/unfolding.html",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jeankossaifi.com/blog/unfolding.html"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Jean Kossaifi",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jeankossaifi.com/static/profile.jpg"
    }
  },
  "image": "https://jeankossaifi.com/static/profile.jpg"
}
</script>
    
    <link rel="stylesheet" href="https://jeankossaifi.com/static/theme.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    

<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
    
    <script src="https://jeankossaifi.com/static/theme.js"></script>
</head>
<body class="antialiased bg-white dark:bg-slate-900 text-gray-900 dark:text-white">
    <div class="elysian-background noise-texture"></div>
<header class="fixed top-0 left-0 right-0 z-50">
    <nav class="bg-white/80 dark:bg-slate-900/80 backdrop-blur-lg">
        <div class="max-w-7xl mx-auto px-6 lg:px-8">
            <div class="flex justify-between items-center h-20 border-b border-gray-200/80 dark:border-gray-800/80">
                <a href="https://jeankossaifi.com/index.html" class="text-xl font-bold heading text-gray-900 dark:text-white">Jean Kossaifi</a>
                <div class="flex items-center gap-4">
                    <ul class="hidden lg:flex items-center gap-6">
                        <li><a href="https://jeankossaifi.com/publications.html" class="text-sm font-medium transition-colors text-gray-600 dark:text-gray-300 hover:text-teal-600 dark:hover:text-teal-400">Publications</a></li>
                        <li><a href="https://jeankossaifi.com/projects.html" class="text-sm font-medium transition-colors text-gray-600 dark:text-gray-300 hover:text-teal-600 dark:hover:text-teal-400">Projects</a></li>
                        <li><a href="https://jeankossaifi.com/news.html" class="text-sm font-medium transition-colors text-gray-600 dark:text-gray-300 hover:text-teal-600 dark:hover:text-teal-400">News</a></li>
                        <li><a href="https://jeankossaifi.com/blog.html" class="text-sm font-medium transition-colors text-teal-600 dark:text-teal-400 font-semibold">Blog</a></li>
                    </ul>
                    <button onclick="toggleDarkMode()" class="w-10 h-10 flex items-center justify-center rounded-full text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors" aria-label="Toggle dark mode">
                        <i id="theme-icon" class="fas fa-moon"></i>
                    </button>
                    <button onclick="toggleMobileMenu()" class="lg:hidden w-10 h-10 flex items-center justify-center rounded-full text-gray-600 dark:text-gray-300" aria-label="Open Menu">
                        <i class="fas fa-bars"></i>
                    </button>
                </div>
                </div>
            </div>
        </div>
    </nav>
    <div id="mobile-menu" class="fixed inset-0 bg-white/95 dark:bg-slate-900/95 backdrop-blur-lg z-50 flex items-center justify-center
                                opacity-0 invisible transition-opacity duration-300">
        <button onclick="toggleMobileMenu()" class="absolute top-6 right-6 w-12 h-12 flex items-center justify-center text-gray-600 dark:text-gray-300" aria-label="Close Menu">
            <i class="fas fa-times fa-lg"></i>
        </button>
        <ul class="text-center space-y-8">
            <li><a href="https://jeankossaifi.com/publications.html" onclick="toggleMobileMenu()" class="text-3xl heading text-gray-900 dark:text-white">Publications</a></li>
            <li><a href="https://jeankossaifi.com/projects.html" onclick="toggleMobileMenu()" class="text-3xl heading text-gray-900 dark:text-white">Projects</a></li>
            <li><a href="https://jeankossaifi.com/news.html" onclick="toggleMobileMenu()" class="text-3xl heading text-gray-900 dark:text-white">News</a></li>
            <li><a href="https://jeankossaifi.com/blog.html" onclick="toggleMobileMenu()" class="text-3xl heading text-gray-900 dark:text-white">Blog</a></li>
        </ul>
    </div>
</header>    <main>
<div class="max-w-7xl mx-auto px-6 lg:px-8 pt-32 pb-20">
    <div class="max-w-4xl mx-auto">
        <header class="mb-16 reveal">
            <h1 class="text-5xl lg:text-6xl heading text-gray-900 dark:text-white mb-4">Tensor Unfolding</h1>
            <p class="text-lg text-gray-500 dark:text-gray-400 mb-8">2017-03-19</p>
        </header>

        <article class="prose-main">
            <p>It is hard, if not impossible, to produce good software in Machine Learning without touching both programming and mathematics. Implementation of tensor unfolding is a very good example of that.</p>
<p>Tensor unfolding, or <strong>matrization</strong>, is a fundamental operation and a building block for most tensor methods. Considering a tensor as a multi-dimensional array, <strong>unfolding</strong> it consists of reading its element in such a way as to obtain a matrix instead of a tensor. mode-k unfolding is obtained by considering the $k^{th}$ mode as the first dimension of a matrix and collapsing the other into the other dimension of that matrix. For a tensor of size $(I_1, I_2, \cdots, I_n)$, the k-mode unfolding of this tensor will be of size $(I_k, I_1 \times \cdots \times I_{k-1} \times I_{k+1} \cdots \times I_n)$. There are different ways of doing this, differing by the order in which the dimensions are collapsed, and each definition impacts the mathematical properties and the performance.</p>
<p>In TensorLy, to offer competitive speed, we had to depart from the traditional definition of <em>unfolding</em> to a formulation offering both better performance in NumPy <em>and</em> nice mathematical properties.</p>
<h1>Performance comparison in NumPy</h1>
<p>To compare the performance of the various implementations of tensor unfolding in NumPy using both defitions, we timed them on a tensor of size $(100, 10, 15, 10, 100)$, for each mode. This graph presents the average accross the modes of the unfolding time (obtained using the timeit module):</p>
<p><img alt="Comparison of the unfolding in NumPy with Kolda&amp;Bader and TensorLy definitions" class="center" height="15em" src="https://jeankossaifi.com/static/images/tensorly/unfolding_comparison.png" /></p>
<p>If you want more details on the implementations, read on!</p>
<h2>Unfolding as defined by Kolda and Bader</h2>
<h3>Formal defintion</h3>
<p>The most common definition of unfolding is the one defined and popularised by the seminal of Kolda and Bader (if you are interested, read their comprehensive paper "Tensor Decompositions and Applications"in SIAM REVIEW, 2009).</p>
<p>We will call that definition of unfolding, that of... Kolda&amp;Bader! They define unfolding as follows:</p>
<p>Let $\tilde X \in \mathbb{R}^{I_1 \times I_2 \times \cdots \times I_N}$ be a size $(I_1 \times I_2 \times \cdots \times I_N)$ tensor, then element $(i_1 \times i_2 \times \cdots \times i_N)$ of $\tilde X$ maps to element $(i_n, j)$ of $\tilde X^{Kolda}_{[n]}$, the n-mode unfolding of $\tilde X$, with:</p>
<p>$$\begin{aligned}
j = 1 + \sum_{\substack{k=1\ k \neq n}}^N \left[ (i_k - 1) \prod_{\substack{m=1\m \neq n}}^{k-1} I_m \right]
\end{aligned}$$</p>
<p>Note that if indexing starts at zero, the previous formula simplifies to:</p>
<p>$$\begin{aligned}
j = \sum_{\substack{k=1\ k \neq n}}^N \left[ i_k \times \prod_{\substack{m=1\m \neq n}}^{k-1} I_m \right]
\end{aligned}$$</p>
<p>For those used to manipulating arrays, you might recognise here the Fortran ordering of elements!</p>
<h3>Example</h3>
<p>Note that we index the modes (dimensions) of a tensor from 0, not 1.</p>
<p>Let's take for this example the tensor $\tilde X$ of size $(3, 4, 2)$ defined by the frontal slices as follows:</p>
<p>$$\begin{aligned}
X_0 = 
\left[
\begin{matrix}
0  &amp; 2  &amp; 4  &amp; 6\
8  &amp; 10 &amp; 12 &amp; 14\
16 &amp; 18 &amp; 20 &amp; 22
\end{matrix}
\right]
\end{aligned}$$</p>
<p>and</p>
<p>$$\begin{aligned}
X_1 =
\left[
\begin{matrix}
1  &amp; 3  &amp; 5  &amp; 7\
9  &amp; 11 &amp; 13 &amp; 15\
17 &amp; 19 &amp; 21 &amp; 23
\end{matrix}
\right]
\end{aligned}$$</p>
<p>Then, according to Kolda's definition, its unfolding are given by:</p>
<h4>mode-0 unfolding:</h4>
<p>$$\begin{aligned}
\tilde X^{Kolda}_{[0]} = 
\left[ \begin{matrix}
   0 &amp; 2 &amp; 4 &amp; 6 &amp; 1 &amp; 3 &amp; 5 &amp; 7\ 
   8 &amp; 10 &amp; 12 &amp; 14 &amp; 9 &amp; 11 &amp; 13 &amp; 15\ 
   16 &amp; 18 &amp; 20 &amp; 22 &amp; 17 &amp; 19 &amp; 21 &amp; 23\ 
 \end{matrix} \right]
\end{aligned}$$</p>
<h4>mode-1 unfolding:</h4>
<p>$$\begin{aligned}
\tilde X^{Kolda}_{[1]} = 
 \left[ \begin{matrix}
   0 &amp; 8 &amp; 16 &amp; 1 &amp; 9 &amp; 17\ 
   2 &amp; 10 &amp; 18 &amp; 3 &amp; 11 &amp; 19\ 
   4 &amp; 12 &amp; 20 &amp; 5 &amp; 13 &amp; 21\ 
   6 &amp; 14 &amp; 22 &amp; 7 &amp; 15 &amp; 23\ 
 \end{matrix} \right]
\end{aligned}$$</p>
<h4>mode-2 unfolding:</h4>
<p>$$\begin{aligned}
\tilde X^{Kolda}_{[2]} = 
\left[ \begin{matrix}
   0 &amp; 8 &amp; 16 &amp; 2 &amp; 10 &amp; 18 &amp; 4 &amp; 12 &amp; 20 &amp; 6 &amp; 14 &amp; 22\ 
   1 &amp; 9 &amp; 17 &amp; 3 &amp; 11 &amp; 19 &amp; 5 &amp; 13 &amp; 21 &amp; 7 &amp; 15 &amp; 23\ 
 \end{matrix} \right]
\end{aligned}$$</p>
<h3>Properties</h3>
<p>Given a tensor $\tilde{X} \in \mathbb{R}^{I_1 \times I_2 \times \cdots \times I_N}$ and its Tucker decomposition $[!![~\tilde{G};~\mathbf{U}^{(1)}, \cdots, \mathbf{U}^{(N)}~]!!]$, we can express the mode-$n$ unfolding of $\tilde{X}$ as:</p>
<p>$$\mathbf{X}<em _n_="[n]">{[n]} = \mathbf{U}^{(n)} \mathbf{G}</em>
                     \otimes \cdots \mathbf{U}^{(n+1)} \otimes \mathbf{U}^{(n-1)}
                     \otimes \cdots \otimes \mathbf{U}^{(1)} \right)^T$$} \left(\mathbf{U}^{(N)</p>
<p>Notice the reverse order of the kronecker product of the matrix factors, that arises from the Fortran ordering of the elements when vectorising/folding/unfolding a tensor.</p>
<h2>Unfolding in TensorLy</h2>
<h3>Formal definition</h3>
<p>In TensorLy, given a tensor $\tilde X \in \mathbb{R}^{I_1 \times I_2 \times \cdots \times I_N}$, we define the mode-n unfolding of $\tilde X$ as a matrix $\mathbf{X}^{TensorLy}<em _neq="\neq" _substack_k="1,\k" n="n">{[n]} \in \mathbb{R}^{I_n, I_M}$, with $M = \prod</em>^N I_k$ and is defined by the mapping from element $(i_1, i_2, \cdots, i_N)$ to $(i_n, j)$, with}</p>
<p>$$\begin{aligned}
j = \sum_{\substack{k=1,\k \neq n}}^N i_k \times \prod_{m=k+1}^N I_m.
\end{aligned}$$</p>
<h3>Example</h3>
<p>Using the same tensor $\tilde X$ as defined previously, the unfoldings according to this new definition are given by:</p>
<h4>mode-0 unfolding:</h4>
<p>$$\begin{aligned}
\tilde X^{TensorLy}_{[0]} = 
\left[ \begin{matrix}
   0 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7\ 
   8 &amp; 9 &amp; 10 &amp; 11 &amp; 12 &amp; 13 &amp; 14 &amp; 15\ 
   16 &amp; 17 &amp; 18 &amp; 19 &amp; 20 &amp; 21 &amp; 22 &amp; 23\ 
 \end{matrix} \right]
\end{aligned}$$</p>
<h4>mode-1 unfolding:</h4>
<p>$$\begin{aligned}
\tilde X^{TensorLy}_{[1]} = 
\left[ \begin{matrix}
   0 &amp; 1 &amp; 8 &amp; 9 &amp; 16 &amp; 17\ 
   2 &amp; 3 &amp; 10 &amp; 11 &amp; 18 &amp; 19\ 
   4 &amp; 5 &amp; 12 &amp; 13 &amp; 20 &amp; 21\ 
   6 &amp; 7 &amp; 14 &amp; 15 &amp; 22 &amp; 23\ 
 \end{matrix} \right]
\end{aligned}$$</p>
<h4>mode-2 unfolding:</h4>
<p>$$\begin{aligned}
\tilde X^{TensorLy}_{[2]} = 
\left[ \begin{matrix}
   0 &amp; 2 &amp; 4 &amp; 6 &amp; 8 &amp; 10 &amp; 12 &amp; 14 &amp; 16 &amp; 18 &amp; 20 &amp; 22\ 
   1 &amp; 3 &amp; 5 &amp; 7 &amp; 9 &amp; 11 &amp; 13 &amp; 15 &amp; 17 &amp; 19 &amp; 21 &amp; 23\ 
 \end{matrix} \right]
\end{aligned}$$</p>
<h3>Properties</h3>
<p>One of the nice things with this definition of the unfolding is that it offers nice properties.</p>
<p>Firstly, you might have recognised a C-ordering of the elements: as a result, this formulation leads to much more natural implementations and achieves better performance when using C-ordering of the elements (as numpy does by default). All that is now required is to move the required dimension into the first position and reshape the result into a matrix.</p>
<p>This definition also translates into more natural properties. For instance, given a tensor $\tilde{X} \in \mathbb{R}^{I_1 \times I_2 \times \cdots \times I_N}$ and its Tucker decomposition $[!![~\tilde{G};~\mathbf{U}^{(1)}, \cdots, \mathbf{U}^{(N)}~]!!]$, we can express the mode-$n$ unfolding of $\tilde{X}$ as:</p>
<p>$$\mathbf{X}<em _n_="[n]">{[n]} = \mathbf{U}^{(n)} \mathbf{G}</em>
                     \otimes \cdots \mathbf{U}^{(n-1)} \otimes \mathbf{U}^{(n+1)}
                     \otimes \cdots \otimes \mathbf{U}^{(N)} \right)^T$$} \left(\mathbf{U}^{(1)</p>
<h3>Example with code, using TensorLy</h3>
<p>In TensorLy, we simply define tensors as numpy arrays (which are already multi-dimensional arrays, i.e. tensors):</p>
<div class="codehilite"><pre><span></span><code><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span>
               <span class="p">[</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">],</span>
               <span class="p">[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">],</span>
               <span class="p">[</span> <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">]],</span>

              <span class="p">[[</span> <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">]],</span>

              <span class="p">[[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">]]])</span>
</code></pre></div>

<p>You can quickly check the frontal slices as follows:</p>
<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">X</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">6</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">22</span><span class="p">]])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">X</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">7</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">23</span><span class="p">]])</span>
</code></pre></div>

<p>To unfold a tensor, simply use the <code>unfold</code> function from TensorLy:</p>
<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span><span class="w"> </span><span class="nn">tensorly</span><span class="w"> </span><span class="kn">import</span> <span class="n">unfold</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">unfold</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">]])</span>
</code></pre></div>

<h2>Implementing tensor unfolding as defined by Kolda and Bader</h2>
<p>In order to provide a good comparison of the different methods, we need a good implementation. However, tensor manipulation is not always very intuitive, as you will see. If you are curious as to the how and why of our implementations, read on!</p>
<h3>Unfolding and ordering of the elements</h3>
<p>Consider the tensor <code>X</code> defined above: you might be tempted to get the mode-0 unfolding as defined by Kolda and Bader by simply reshaping it into a matrix of size <code>(3, 4*2)</code>. However, this is what happens if you do:</p>
<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">22</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">23</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">24</span><span class="p">]])</span>
</code></pre></div>

<p>What happened here?</p>
<p>Writing <code>X.reshape((3, -1))</code> is equivalent to writing: <code>X.reshape((3, -1), order='C')</code>. In other words, the elements are read in <strong>C-order</strong>. Which means that the elements from the <strong>last</strong> axis are contiguous in memory and read first: you can see this by flattening the array in the default order (<em>C order</em>).</p>
<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">X</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="c1"># equivalent to X.ravel(order=&#39;C&#39;)</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>
       <span class="mi">15</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">24</span><span class="p">])</span>
</code></pre></div>

<p>What you really want is to read the elements column-wise, i.e. in <strong>Fortran order</strong>: indeed, if you <code>reshape</code> the array in <code>Fortran</code> order, you obtain the mode-0 unfolding:</p>
<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">22</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">23</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">24</span><span class="p">]])</span>
</code></pre></div>

<h3>Unfolding using reshaping in F-order</h3>
<p>Based on the above discussion, a simple function to unfold a tensor would be the following:</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">f_unfold</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simple unfolding function</span>
<span class="sd">        Moves the `mode` axis to the beginning and reshapes in Fortran order</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">mode</span><span class="p">),</span> <span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
</code></pre></div>

<p>Yes <strong>but</strong>...</p>
<p>1)  we work mostly in C-order
2)  moving the axis and reshaping in Fortran order is slow if you manipulate arrays in C-order, which they are by default in numpy which leads us to...
3)  <em>always try to use the defaults users expect</em>. This is the <em>Principle of least astonishment</em>.</p>
<h3>Unfolding using reshaping in C-order: playing with strides and shape</h3>
<p>As we said, what we want is the mode-axis first, then the other dimensions in the correct order. Let's take the example of mode-0 unfolding: when we form <code>X.reshape((mode, 4*2))</code>, the elements of the <strong>last</strong> mode come first, while the first mode should. (One way to look at it is that the reshaping returns a tensor of size $(I_k, I_n \times \cdots \times I_{k+1} \times I_{k-1} \cdots \times I_1)$ instead of $(I_k, I_1 \times \cdots \times I_{k-1} \times I_{k+1} \cdots \times I_n)$):</p>
<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">22</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">23</span><span class="p">],</span>
       <span class="p">[</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">24</span><span class="p">]])</span>
</code></pre></div>

<p>To correct this, we need to re-arange the dimensions of the tensor before reshaping.</p>
<h4>In Pseudo code:</h4>
<blockquote>
<p><strong>function</strong> <code>unfold(tensor, mode=k)</code>:</p>
<p><strong>Input</strong>: tensor of size $(I_1, \cdots I_n)$ to unfold in mode $k$.</p>
<dl>
<dt>- | <em>put the</em> $k^{th}$ <em>axis of</em> <code>tensor</code> <em>first:</em></dt>
<dd>
<p>| $(I_1, \cdots I_n) \rightarrow(I_k, I_1 \times \cdots \times I_{k-1} \times I_{k+1} \cdots \times I_n)$</p>
</dd>
<dt>- | <em>Reverse the order of the remaning axis of</em> <code>tensor</code>:</dt>
<dd>
<p>| $(I_k, I_1 \times \cdots \times I_{k-1} \times I_{k+1} \cdots \times I_n) \rightarrow (I_k, I_n \times \cdots \times I_{k+1} \times I_{k-1} \cdots \times I_1)$</p>
</dd>
<dt>- | <em>Reshape in C order:</em></dt>
<dd>
<p>| <code>reshape(tensor, (</code>$I_k$ <code>, -1), order='C'))</code></p>
</dd>
</dl>
</blockquote>
<h4>Actual code</h4>
<p>Let's write an intermediate function to give us the reordering of the axis. For instance, for a tensor of order 5, the reordering corresponding to 2-mode unfoding should be:</p>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>

<p>The function to do this is simple:</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">reorder</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reorders the elements</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
    <span class="n">element</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">([</span><span class="n">element</span><span class="p">]</span> <span class="o">+</span> <span class="n">indices</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div>

<p>Using this, the actual function to unfold a tensor is the following:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">numpy.lib.stride_tricks</span><span class="w"> </span><span class="kn">import</span> <span class="n">as_strided</span>

<span class="k">def</span><span class="w"> </span><span class="nf">c_unfold</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the mode-`mode` unfolding of `tensor` </span>
<span class="sd">        (modes start at `0`)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">strides</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">strides</span><span class="p">)</span>
    <span class="n">fibers_len</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">reorder</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="n">strides</span> <span class="o">=</span> <span class="n">reorder</span><span class="p">(</span><span class="n">strides</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">as_strided</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">fibers_len</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div>

<h3>A shorter version</h3>
<p>The previous code can be written equivalently in a much shorter way using numpy's built-in <code>transpose</code> function that takes care of changing the strides and the shape for us:</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">unfold</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the mode-`mode` unfolding of `tensor` </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">reorder</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">mode</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div>

<h3>Timing all these candidates</h3>
<p>This is all well and good but which of these functions is actually faster: we have mentioned this already, but let us see what it is in practice. I have run each method on a tensor of size $(100, 10, 15, 10, 100)$, using the timeit function from the timeit module.</p>
<p><img alt="comparison of the unfolding in NumPy with various implementations of the Kolda&amp;Bader definition and the TensorLy definition" class="wide center" src="https://jeankossaifi.com/static/images/tensorly/unfolding_implementation_comparison.png" /></p>
<h2>Refolding a tensor using the Kolda and Bader defition</h2>
<p>Using the introduced TensorLy convention, folding is simply a reshaping in Numpy, followed by a moveaxis to invert the effect of the folding. For completeness, I will go over refolding an unfolded tensor using Kolda and Bader's definition, which are slightly more tricky to do on a tensor represented by a C-style array.</p>
<p>Once you understand how to properly unfold a tensor, refolding it is still fairly easy: we just need to put the dimensions composing the rows back in order and then switch the first dimension where it belong in $k$-th position.</p>
<h3>With strides</h3>
<p>We can use our knowledge on the ordering of the elements in the rows of the matrix to directly set the strides and the shape. Knowing the size of an element (in bytes), and the number of elements per dimension, we can easily determine the number of bytes to skip to go to the next dimension (<em>strides</em>):</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">c_fold</span><span class="p">(</span><span class="n">unfolded</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the folded tensor of shape `shape` from the `mode`-mode unfolding `unfolded`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">column_size</span><span class="p">,</span> <span class="n">element_size</span> <span class="o">=</span> <span class="n">unfolded</span><span class="o">.</span><span class="n">strides</span>
    <span class="n">column_dimensions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># the mode-dimension is contained in the columns</span>
    <span class="n">column_dimensions</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
    <span class="c1"># the elements of a row are ordered as the first dimension, then the 2nd, etc</span>
    <span class="c1"># to read the first, skip 0 elements</span>
    <span class="c1"># to read the second dimension, skip n_elements_first_dimension, etc.</span>
    <span class="n">column_dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">column_dimensions</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="c1"># number of bytes to skip to go from one element to another</span>
    <span class="n">strides</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="o">*</span> <span class="n">element_size</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">column_dimensions</span><span class="p">]</span>
    <span class="c1"># To go to the next element in dimension mode, we go to the next line of the unfolded tensor</span>
    <span class="n">strides</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">column_size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">as_strided</span><span class="p">(</span><span class="n">unfolded</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
</code></pre></div>

<h3>Concise solution</h3>
<p>Again, it is faster and clearer to let numpy do the work. We first reshape the unfolded tensor into a tensor after the transposition was done. Then we undo the transpose:</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fold</span><span class="p">(</span><span class="n">unfolded</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the folded tensor of shape `shape` from the `mode`-mode unfolding `unfolded`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unfolded_indices</span> <span class="o">=</span> <span class="n">reorder</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)),</span> <span class="n">mode</span><span class="p">)</span>
    <span class="n">original_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unfolded_indices</span><span class="p">]</span>
    <span class="n">unfolded</span> <span class="o">=</span> <span class="n">unfolded</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>

    <span class="n">folded_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">folded_indices</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">unfolded</span><span class="p">,</span> <span class="n">folded_indices</span><span class="p">)</span>
</code></pre></div>

<h2>Final words</h2>
<p>By simply redifining the unfoding operator we were able to gain a significant speedup. Tensor unfolding is ubuquitous in multi-linear algebra, used in all kind of algorithms from higher order SVD to tensor regression and the speedup translates into faster algorithms. Not only that it also translates into nice mathematical properties and a natural implemenation in Python.</p>
        </article>

    </div>
</div></main>
<footer class="bg-surface dark:bg-dark-surface mt-24">
    <div class="max-w-7xl mx-auto px-6 lg:px-8 py-16">
        <div class="flex flex-col md:flex-row justify-between items-center gap-8 text-center md:text-left">
            <p class="text-secondary dark:text-dark-secondary">© 2025 Jean Kossaifi</p>
            <div class="flex justify-center gap-6 text-secondary dark:text-dark-secondary">
<a href="https://github.com/JeanKossaifi" target="_blank" rel="noopener" aria-label="GitHub" class="hover:text-accent dark:hover:text-dark-accent transition-colors"><i class="fab fa-github fa-lg"></i></a><a href="https://scholar.google.co.uk/citations?user=hJS2TXwAAAAJ" target="_blank" rel="noopener" aria-label="Google Scholar" class="hover:text-accent dark:hover:text-dark-accent transition-colors"><i class="fas fa-graduation-cap fa-lg"></i></a><a href="https://uk.linkedin.com/in/jeankossaifi" target="_blank" rel="noopener" aria-label="LinkedIn" class="hover:text-accent dark:hover:text-dark-accent transition-colors"><i class="fab fa-linkedin fa-lg"></i></a><a href="https://twitter.com/JeanKossaifi" target="_blank" rel="noopener" aria-label="Twitter" class="hover:text-accent dark:hover:text-dark-accent transition-colors"><i class="fab fa-twitter fa-lg"></i></a>            </div>
        </div>
    </div>
</footer></body>
</html>